/*{
  date: "2026-01-28",
  irmf: "1.0",
  language: "glsl",
  materials: ["porcelain"],
  min: [-3.3,-2.1,0],
  max: [3.6,2.1,3.3],
  title: "Utah Teapot (Solid Bezier)",
  units: "mm",
  version: "1.0",
}*/

precision highp float;

// Cubic Bezier evaluation
vec2 bezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {
    float u = 1.0 - t;
    return u*u*u*p0 + 3.0*u*u*t*p1 + 3.0*u*t*t*p2 + t*t*t*p3;
}

// Ray-casting intersection for 2D profile
int intersectBezier(vec2 p, vec2 p0, vec2 p1, vec2 p2, vec2 p3) {
    int count = 0;
    vec2 prev = p0;
    const int samples = 20;
    for (int i = 1; i <= samples; i++) {
        vec2 curr = bezier(p0, p1, p2, p3, float(i) / float(samples));
        if (((prev.y <= p.y && p.y < curr.y) || (curr.y <= p.y && p.y < prev.y))) {
            float x = prev.x + (curr.x - prev.x) * (p.y - prev.y) / (curr.y - prev.y);
            if (x > p.x) count++;
        }
        prev = curr;
    }
    return count;
}

int intersectLine(vec2 p, vec2 p0, vec2 p1) {
    if (((p0.y <= p.y && p.y < p1.y) || (p1.y <= p.y && p.y < p0.y))) {
        float x = p0.x + (p1.x - p0.x) * (p.y - p0.y) / (p1.y - p0.y);
        if (x > p.x) return 1;
    }
    return 0;
}

// B-Spline evaluation (clamped cubic)
vec2 bspline(vec2 p[9], float t) {
    float mt = t * 6.0;
    int seg = int(floor(mt));
    if (seg < 0) seg = 0; if (seg > 5) seg = 5;
    float f = mt - float(seg);
    if (seg == 0) return bezier(p[0], p[1], p[2], (p[2]+p[3])*0.5, f);
    if (seg == 5) return bezier((p[5]+p[6])*0.5, p[6], p[7], p[8], f);
    vec2 c0 = (p[seg]+p[seg+1])*0.5; vec2 c1 = p[seg+1]; vec2 c2 = p[seg+2]; vec2 c3 = (p[seg+2]+p[seg+3])*0.5;
    return bezier(c0, c1, c2, c3, f);
}

int intersectBSpline(vec2 p, vec2 ctrl[9]) {
    int count = 0;
    vec2 prev = ctrl[0];
    const int samples = 40;
    for (int i = 1; i <= samples; i++) {
        vec2 curr = bspline(ctrl, float(i) / float(samples));
        if (((prev.y <= p.y && p.y < curr.y) || (curr.y <= p.y && p.y < prev.y))) {
            float x = prev.x + (curr.x - prev.x) * (p.y - prev.y) / (curr.y - prev.y);
            if (x > p.x) count++;
        }
        prev = curr;
    }
    return count;
}

vec2 bsplineLid(vec2 p[12], float t) {
    float mt = t * 9.0;
    int seg = int(floor(mt));
    if (seg < 0) seg = 0; if (seg > 8) seg = 8;
    float f = mt - float(seg);
    if (seg == 0) return bezier(p[0], p[1], p[2], (p[2]+p[3])*0.5, f);
    if (seg == 8) return bezier((p[8]+p[9])*0.5, p[9], p[10], p[11], f);
    vec2 c0 = (p[seg]+p[seg+1])*0.5; vec2 c1 = p[seg+1]; vec2 c2 = p[seg+2]; vec2 c3 = (p[seg+2]+p[seg+3])*0.5;
    return bezier(c0, c1, c2, c3, f);
}

int intersectBSplineLid(vec2 p, vec2 ctrl[12]) {
    int count = 0;
    vec2 prev = ctrl[0];
    const int samples = 50;
    for (int i = 1; i <= samples; i++) {
        vec2 curr = bsplineLid(ctrl, float(i) / float(samples));
        if (((prev.y <= p.y && p.y < curr.y) || (curr.y <= p.y && p.y < prev.y))) {
            float x = prev.x + (curr.x - prev.x) * (p.y - prev.y) / (curr.y - prev.y);
            if (x > p.x) count++;
        }
        prev = curr;
    }
    return count;
}

bool isInsideBody(vec3 xyz, bool outside) {
    float r = length(xyz.xz);
    vec2 p = vec2(r, xyz.y);
    int count = 0;
    if (outside) {
        count += intersectBezier(p, vec2(1.4, 2.25), vec2(1.3375, 2.38125), vec2(1.4375, 2.38125), vec2(1.5, 2.25));
        count += intersectBezier(p, vec2(1.5, 2.25), vec2(1.75, 1.725), vec2(2.0, 1.2), vec2(2.0, 0.75));
        count += intersectBezier(p, vec2(2.0, 0.75), vec2(2.0, 0.3), vec2(1.5, 0.075), vec2(1.5, 0.0));
        count += intersectLine(p, vec2(1.5, 0.0), vec2(0.0, 0.0));
        count += intersectLine(p, vec2(0.0, 0.0), vec2(0.0, 2.25));
        count += intersectLine(p, vec2(0.0, 2.25), vec2(1.4, 2.25));
    } else {
        vec2 ctrl[9];
        ctrl[0] = vec2(1.4, 2.25); ctrl[1] = vec2(1.3, 2.25); ctrl[2] = vec2(1.2, 2.25);
        ctrl[3] = vec2(1.2, 2.15); ctrl[4] = vec2(1.5, 2.12); ctrl[5] = vec2(2.0, 0.6);
        ctrl[6] = vec2(1.4, 0.2); ctrl[7] = vec2(1.3, 0.15); ctrl[8] = vec2(1.1, 0.15);
        count += intersectBSpline(p, ctrl);
        count += intersectLine(p, vec2(1.1, 0.15), vec2(0.0, 0.15));
        count += intersectLine(p, vec2(0.0, 0.15), vec2(0.0, 2.25));
        count += intersectLine(p, vec2(0.0, 2.25), vec2(1.4, 2.25));
    }
    return (count % 2) != 0;
}

bool isInsideLid(vec3 xyz, bool outside) {
    float r = length(xyz.xz);
    vec2 p = vec2(r, xyz.y);
    int count = 0;
    if (outside) {
        count += intersectBezier(p, vec2(0.01, 3.0), vec2(0.8, 3.0), vec2(0.0, 2.7), vec2(0.2, 2.55));
        count += intersectBezier(p, vec2(0.2, 2.55), vec2(0.4, 2.4), vec2(1.3, 2.4), vec2(1.3, 2.25));
        count += intersectLine(p, vec2(1.3, 2.25), vec2(0.0, 2.25));
        count += intersectLine(p, vec2(0.0, 2.25), vec2(0.0, 3.0));
        count += intersectLine(p, vec2(0.0, 3.0), vec2(0.01, 3.0));
    } else {
        vec2 ctrl[12];
        ctrl[0] = vec2(1.3, 2.25); ctrl[1] = vec2(1.2, 2.25); ctrl[2] = vec2(1.18, 2.25);
        ctrl[3] = vec2(1.15, 2.15); ctrl[4] = vec2(1.1, 2.2); ctrl[5] = vec2(1.0, 2.32);
        ctrl[6] = vec2(0.5, 2.35); ctrl[7] = vec2(0.07, 2.48); ctrl[8] = vec2(0.07, 2.66);
        ctrl[9] = vec2(0.26, 2.87); ctrl[10] = vec2(0.2, 2.91); ctrl[11] = vec2(0.05, 2.91);
        count += intersectBSplineLid(p, ctrl);
        count += intersectLine(p, vec2(0.05, 2.91), vec2(0.0, 2.91));
        count += intersectLine(p, vec2(0.0, 2.91), vec2(0.0, 2.25));
        count += intersectLine(p, vec2(0.0, 2.25), vec2(1.3, 2.25));
    }
    return (count % 2) != 0;
}

float projectToBezier(vec2 q, vec2 p0, vec2 p1, vec2 p2, vec2 p3) {
    float bestT = 0.5; float minDist = 1e10;
    for (int i = 0; i <= 10; i++) {
        float t = float(i) / 10.0;
        float d = length(q - bezier(p0, p1, p2, p3, t));
        if (d < minDist) { minDist = d; bestT = t; }
    }
    float delta = 0.05;
    for (int j = 0; j < 3; j++) {
        float t1 = clamp(bestT - delta, 0.0, 1.0); float t2 = clamp(bestT + delta, 0.0, 1.0);
        float d1 = length(q - bezier(p0, p1, p2, p3, t1)); float d2 = length(q - bezier(p0, p1, p2, p3, t2));
        if (d1 < d2) { if (d1 < minDist) { minDist = d1; bestT = t1; } }
        else { if (d2 < minDist) { minDist = d2; bestT = t2; } }
        delta *= 0.5;
    }
    return bestT;
}

bool isInsideHandle(vec3 xyz) {
    // Average path of Row 0 and Row 3 from Handle patches
    vec2 p0 = vec2(-1.55, 1.9875); vec2 p1 = vec2(-2.4, 1.9875); vec2 p2 = vec2(-2.85, 1.9875); vec2 p3 = vec2(-2.85, 1.65);
    vec2 p4 = vec2(-2.85, 1.3125); vec2 p5 = vec2(-2.575, 0.88125); vec2 p6 = vec2(-1.95, 0.6);
    float t1 = projectToBezier(xyz.xy, p0, p1, p2, p3); float d1 = length(xyz.xy - bezier(p0, p1, p2, p3, t1));
    float t2 = projectToBezier(xyz.xy, p3, p4, p5, p6); float d2 = length(xyz.xy - bezier(p3, p4, p5, p6, t2));
    float d = min(d1, d2);
    float r_xy = 0.15; float r_z = 0.225; // Based on control points
    return (d*d)/(r_xy*r_xy) + (xyz.z*xyz.z)/(r_z*r_z) < 1.0;
}

float bezier1D(float p0, float p1, float p2, float p3, float t) {
    float u = 1.0 - t;
    return u*u*u*p0 + 3.0*u*u*t*p1 + 3.0*u*t*t*p2 + t*t*t*p3;
}

float distToSegment(vec2 p, vec2 a, vec2 b, out float w) {
    vec2 ba = b - a;
    float l2 = dot(ba, ba);
    if (l2 < 1e-6) { w = 0.0; return length(p - a); }
    w = clamp(dot(p - a, ba) / l2, 0.0, 1.0);
    return length(p - (a + w * ba));
}

bool testHump(vec3 p, vec2 q0[4], vec2 q3[4], float zc[4], float xyScale, float zScale) {
    float bestV = 0.5; float minDist = 1e10; float bestW = 0.0;
    for (int i = 0; i <= 24; i++) {
        float v = float(i) / 24.0;
        vec2 A = bezier(q0[0], q0[1], q0[2], q0[3], v);
        vec2 B = bezier(q3[0], q3[1], q3[2], q3[3], v);
        if (xyScale != 1.0) {
            vec2 C = (A + B) * 0.5;
            A = C + (A - C) * xyScale;
            B = C + (B - C) * xyScale;
        }
        float w; float d = distToSegment(p.xy, A, B, w);
        if (d < minDist) { minDist = d; bestV = v; bestW = w; }
    }
    float delta = 1.0 / 48.0;
    for (int j = 0; j < 3; j++) {
        float v1 = clamp(bestV - delta, 0.0, 1.0); float v2 = clamp(bestV + delta, 0.0, 1.0);
        vec2 A1 = bezier(q0[0], q0[1], q0[2], q0[3], v1); vec2 B1 = bezier(q3[0], q3[1], q3[2], q3[3], v1);
        vec2 A2 = bezier(q0[0], q0[1], q0[2], q0[3], v2); vec2 B2 = bezier(q3[0], q3[1], q3[2], q3[3], v2);
        if (xyScale != 1.0) {
            vec2 C1 = (A1 + B1) * 0.5; A1 = C1 + (A1 - C1) * xyScale; B1 = C1 + (B1 - C1) * xyScale;
            vec2 C2 = (A2 + B2) * 0.5; A2 = C2 + (A2 - C2) * xyScale; B2 = C2 + (B2 - C2) * xyScale;
        }
        float w1, w2; float d1 = distToSegment(p.xy, A1, B1, w1); float d2 = distToSegment(p.xy, A2, B2, w2);
        if (d1 < d2) { if (d1 < minDist) { minDist = d1; bestV = v1; bestW = w1; } }
        else { if (d2 < minDist) { minDist = d2; bestV = v2; bestW = w2; } }
        delta *= 0.5;
    }
    if (minDist > 0.03) return false;
    float Zv = bezier1D(zc[0], zc[1], zc[2], zc[3], bestV) * zScale;
    float u = 0.5 + sin(asin(clamp(2.0*bestW - 1.0, -1.0, 1.0)) / 3.0);
    return abs(p.z) < Zv * 3.0 * u * (1.0 - u);
}

bool isInsideSpout(vec3 xyz, bool outside) {
    vec2 b0[4]; b0[0]=vec2(1.7, 1.275); b0[1]=vec2(2.6, 1.275); b0[2]=vec2(2.3, 1.95); b0[3]=vec2(2.7, 2.25);
    vec2 b3[4]; b3[0]=vec2(1.7, 0.45); b3[1]=vec2(3.1, 0.675); b3[2]=vec2(2.4, 1.875); b3[3]=vec2(3.3, 2.25);
    float bz[4]; bz[0]=0.66; bz[1]=0.66; bz[2]=0.25; bz[3]=0.25;

    if (!outside) {
        return testHump(xyz, b0, b3, bz, 0.666667, 0.6);
    }

    if (testHump(xyz, b0, b3, bz, 1.0, 1.0)) return true;

    vec2 t0[4]; t0[0]=vec2(2.7, 2.25); t0[1]=vec2(2.8, 2.325); t0[2]=vec2(2.9, 2.325); t0[3]=vec2(2.8, 2.25);
    vec2 t3[4]; t3[0]=vec2(3.3, 2.25); t3[1]=vec2(3.525, 2.34375); t3[2]=vec2(3.45, 2.3625); t3[3]=vec2(3.2, 2.25);
    float tz[4]; tz[0]=0.25; tz[1]=0.25; tz[2]=0.15; tz[3]=0.15;

    return testHump(xyz, t0, t3, tz, 1.0, 1.0);
}

void mainModel4(out vec4 materials, in vec3 pos) {
    vec3 xyz = pos.xzy;
    bool spoutSolid = isInsideSpout(xyz, true) && !isInsideSpout(xyz, false);
    bool bodySolid = isInsideBody(xyz, true) && !isInsideBody(xyz, false);
    bool lidSolid = isInsideLid(xyz, true) && !isInsideLid(xyz, false);
    bool handleSolid = isInsideHandle(xyz);
    
    materials = vec4(0.0);
    if (bodySolid || spoutSolid || lidSolid || handleSolid) materials[0] = 1.0;
}

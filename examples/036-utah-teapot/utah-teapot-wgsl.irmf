/*{
  date: "2026-01-28",
  irmf: "1.0",
  language: "wgsl",
  materials: ["porcelain"],
  min: [-3.3,-2.1,0],
  max: [3.6,2.1,3.3],
  title: "Utah Teapot (Solid Bezier)",
  units: "mm",
  version: "1.0",
}*/

fn bezier(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>, t: f32) -> vec2<f32> {
    let u = 1.0 - t;
    return u*u*u*p0 + 3.0*u*u*t*p1 + 3.0*u*t*t*p2 + t*t*t*p3;
}

fn intersectBezier(p: vec2<f32>, p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>) -> i32 {
    var count: i32 = 0; var prev = p0; let samples: f32 = 20.0;
    for (var i: i32 = 1; i <= 20; i = i + 1) {
        let curr = bezier(p0, p1, p2, p3, f32(i) / samples);
        if (((prev.y <= p.y && p.y < curr.y) || (curr.y <= p.y && p.y < prev.y))) {
            let x = prev.x + (curr.x - prev.x) * (p.y - prev.y) / (curr.y - prev.y);
            if (x > p.x) { count = count + 1; }
        }
        prev = curr;
    }
    return count;
}

fn intersectLine(p: vec2<f32>, p0: vec2<f32>, p1: vec2<f32>) -> i32 {
    if (((p0.y <= p.y && p.y < p1.y) || (p1.y <= p.y && p.y < p0.y))) {
        let x = p0.x + (p1.x - p0.x) * (p.y - p0.y) / (p1.y - p0.y);
        if (x > p.x) { return 1; }
    }
    return 0;
}

fn bspline(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>, p4: vec2<f32>, p5: vec2<f32>, p6: vec2<f32>, p7: vec2<f32>, p8: vec2<f32>, t: f32) -> vec2<f32> {
    let mt = t * 6.0; let seg = i32(floor(mt)); let f = mt - f32(seg);
    if (seg == 0) { return bezier(p0, p1, p2, (p2+p3)*0.5, f); }
    if (seg == 5) { return bezier((p5+p6)*0.5, p6, p7, p8, f); }
    var pts = array<vec2<f32>, 9>(p0, p1, p2, p3, p4, p5, p6, p7, p8);
    let c0 = (pts[seg]+pts[seg+1])*0.5; let c1 = pts[seg+1]; let c2 = pts[seg+2]; let c3 = (pts[seg+2]+pts[seg+3])*0.5;
    return bezier(c0, c1, c2, c3, f);
}

fn intersectBSpline(p: vec2<f32>) -> i32 {
    var count: i32 = 0;
    let p0 = vec2<f32>(1.4, 2.25); let p1 = vec2<f32>(1.3, 2.25); let p2 = vec2<f32>(1.2, 2.25);
    let p3 = vec2<f32>(1.2, 2.15); let p4 = vec2<f32>(1.5, 2.12); let p5 = vec2<f32>(2.0, 0.6);
    let p6 = vec2<f32>(1.4, 0.2); let p7 = vec2<f32>(1.3, 0.15); let p8 = vec2<f32>(1.1, 0.15);
    var prev = p0; let samples: f32 = 40.0;
    for (var i: i32 = 1; i <= 40; i = i + 1) {
        let curr = bspline(p0, p1, p2, p3, p4, p5, p6, p7, p8, f32(i) / samples);
        if (((prev.y <= p.y && p.y < curr.y) || (curr.y <= p.y && p.y < prev.y))) {
            let x = prev.x + (curr.x - prev.x) * (p.y - prev.y) / (curr.y - prev.y);
            if (x > p.x) { count = count + 1; }
        }
        prev = curr;
    }
    return count;
}

fn bsplineLid(t: f32) -> vec2<f32> {
    let p0 = vec2<f32>(1.3, 2.25); let p1 = vec2<f32>(1.2, 2.25); let p2 = vec2<f32>(1.18, 2.25);
    let p3 = vec2<f32>(1.15, 2.15); let p4 = vec2<f32>(1.1, 2.2); let p5 = vec2<f32>(1.0, 2.32);
    let p6 = vec2<f32>(0.5, 2.35); let p7 = vec2<f32>(0.07, 2.48); let p8 = vec2<f32>(0.07, 2.66);
    let p9 = vec2<f32>(0.26, 2.87); let p10 = vec2<f32>(0.2, 2.91); let p11 = vec2<f32>(0.05, 2.91);
    let mt = t * 9.0; let seg = i32(floor(mt)); let f = mt - f32(seg);
    if (seg == 0) { return bezier(p0, p1, p2, (p2+p3)*0.5, f); }
    if (seg == 8) { return bezier((p8+p9)*0.5, p9, p10, p11, f); }
    var pts = array<vec2<f32>, 12>(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
    let c0 = (pts[seg]+pts[seg+1])*0.5; let c1 = pts[seg+1]; let c2 = pts[seg+2]; let c3 = (pts[seg+2]+pts[seg+3])*0.5;
    return bezier(c0, c1, c2, c3, f);
}

fn intersectBSplineLid(p: vec2<f32>) -> i32 {
    var count: i32 = 0; var prev = vec2<f32>(1.3, 2.25); let samples: f32 = 50.0;
    for (var i: i32 = 1; i <= 50; i = i + 1) {
        let curr = bsplineLid(f32(i) / samples);
        if (((prev.y <= p.y && p.y < curr.y) || (curr.y <= p.y && p.y < prev.y))) {
            let x = prev.x + (curr.x - prev.x) * (p.y - prev.y) / (curr.y - prev.y);
            if (x > p.x) { count = count + 1; }
        }
        prev = curr;
    }
    return count;
}

fn isInsideBody(xyz: vec3<f32>, outside: bool) -> bool {
    let r = length(xyz.xz); let p = vec2<f32>(r, xyz.y); var count: i32 = 0;
    if (outside) {
        count = count + intersectBezier(p, vec2<f32>(1.4, 2.25), vec2<f32>(1.3375, 2.38125), vec2<f32>(1.4375, 2.38125), vec2<f32>(1.5, 2.25));
        count = count + intersectBezier(p, vec2<f32>(1.5, 2.25), vec2<f32>(1.75, 1.725), vec2<f32>(2.0, 1.2), vec2<f32>(2.0, 0.75));
        count = count + intersectBezier(p, vec2<f32>(2.0, 0.75), vec2<f32>(2.0, 0.3), vec2<f32>(1.5, 0.075), vec2<f32>(1.5, 0.0));
        count = count + intersectLine(p, vec2<f32>(1.5, 0.0), vec2<f32>(0.0, 0.0));
        count = count + intersectLine(p, vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 2.25));
        count = count + intersectLine(p, vec2<f32>(0.0, 2.25), vec2<f32>(1.4, 2.25));
    } else {
        count = count + intersectBSpline(p);
        count = count + intersectLine(p, vec2<f32>(1.1, 0.15), vec2<f32>(0.0, 0.15));
        count = count + intersectLine(p, vec2<f32>(0.0, 0.15), vec2<f32>(0.0, 2.25));
        count = count + intersectLine(p, vec2<f32>(0.0, 2.25), vec2<f32>(1.4, 2.25));
    }
    return (count % 2) != 0;
}

fn isInsideLid(xyz: vec3<f32>, outside: bool) -> bool {
    let r = length(xyz.xz); let p = vec2<f32>(r, xyz.y); var count: i32 = 0;
    if (outside) {
        count = count + intersectBezier(p, vec2<f32>(0.01, 3.0), vec2<f32>(0.8, 3.0), vec2<f32>(0.0, 2.7), vec2<f32>(0.2, 2.55));
        count = count + intersectBezier(p, vec2<f32>(0.2, 2.55), vec2<f32>(0.4, 2.4), vec2<f32>(1.3, 2.4), vec2<f32>(1.3, 2.25));
        count = count + intersectLine(p, vec2<f32>(1.3, 2.25), vec2<f32>(0.0, 2.25));
        count = count + intersectLine(p, vec2<f32>(0.0, 2.25), vec2<f32>(0.0, 3.0));
        count = count + intersectLine(p, vec2<f32>(0.0, 3.0), vec2<f32>(0.01, 3.0));
    } else {
        count = count + intersectBSplineLid(p);
        count = count + intersectLine(p, vec2<f32>(0.05, 2.91), vec2<f32>(0.0, 2.91));
        count = count + intersectLine(p, vec2<f32>(0.0, 2.91), vec2<f32>(0.0, 2.25));
        count = count + intersectLine(p, vec2<f32>(0.0, 2.25), vec2<f32>(1.3, 2.25));
    }
    return (count % 2) != 0;
}

fn projectToBezier(q: vec2<f32>, p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>) -> f32 {
    var bestT: f32 = 0.5; var minDist: f32 = 1e10;
    for (var i: i32 = 0; i <= 10; i = i + 1) {
        let t = f32(i) / 10.0; let d = length(q - bezier(p0, p1, p2, p3, t));
        if (d < minDist) { minDist = d; bestT = t; }
    }
    var delta: f32 = 0.05;
    for (var j: i32 = 0; j < 3; j = j + 1) {
        let t1 = clamp(bestT - delta, 0.0, 1.0); let t2 = clamp(bestT + delta, 0.0, 1.0);
        let d1 = length(q - bezier(p0, p1, p2, p3, t1)); let d2 = length(q - bezier(p0, p1, p2, p3, t2));
        if (d1 < d2) { if (d1 < minDist) { minDist = d1; bestT = t1; } }
        else { if (d2 < minDist) { minDist = d2; bestT = t2; } }
        delta = delta * 0.5;
    }
    return bestT;
}

fn isInsideHandle(xyz: vec3<f32>) -> bool {
    let p0 = vec2<f32>(-1.55, 1.9875); let p1 = vec2<f32>(-2.4, 1.9875); let p2 = vec2<f32>(-2.85, 1.9875); let p3 = vec2<f32>(-2.85, 1.65);
    let p4 = vec2<f32>(-2.85, 1.3125); let p5 = vec2<f32>(-2.575, 0.88125); let p6 = vec2<f32>(-1.95, 0.6);
    let t1 = projectToBezier(xyz.xy, p0, p1, p2, p3); let d1 = length(xyz.xy - bezier(p0, p1, p2, p3, t1));
    let t2 = projectToBezier(xyz.xy, p3, p4, p5, p6); let d2 = length(xyz.xy - bezier(p3, p4, p5, p6, t2));
    let d = min(d1, d2); let r_xy = 0.15; let r_z = 0.225;
    return (d*d)/(r_xy*r_xy) + (xyz.z*xyz.z)/(r_z*r_z) < 1.0;
}

fn bezier1D(p0: f32, p1: f32, p2: f32, p3: f32, t: f32) -> f32 {
    let u = 1.0 - t;
    return u*u*u*p0 + 3.0*u*u*t*p1 + 3.0*u*t*t*p2 + t*t*t*p3;
}

fn distToSegment(p: vec2<f32>, a: vec2<f32>, b: vec2<f32>, w: ptr<function, f32>) -> f32 {
    let ba = b - a;
    let l2 = dot(ba, ba);
    if (l2 < 1e-6) { *w = 0.0; return length(p - a); }
    *w = clamp(dot(p - a, ba) / l2, 0.0, 1.0);
    return length(p - (a + (*w) * ba));
}

fn testHump(p: vec3<f32>, q0: array<vec2<f32>, 4>, q3: array<vec2<f32>, 4>, zc: array<f32, 4>, xyScale: f32, zScale: f32) -> bool {
    var bestV: f32 = 0.5; var minDist: f32 = 1e10; var bestW: f32 = 0.0;
    for (var i: i32 = 0; i <= 24; i = i + 1) {
        let v = f32(i) / 24.0;
        var A = bezier(q0[0], q0[1], q0[2], q0[3], v);
        var B = bezier(q3[0], q3[1], q3[2], q3[3], v);
        if (xyScale != 1.0) {
            let C = (A + B) * 0.5;
            A = C + (A - C) * xyScale;
            B = C + (B - C) * xyScale;
        }
        var curW: f32 = 0.0;
        let d = distToSegment(p.xy, A, B, &curW);
        if (d < minDist) { minDist = d; bestV = v; bestW = curW; }
    }
    var delta: f32 = 1.0 / 48.0;
    for (var j: i32 = 0; j < 3; j = j + 1) {
        let v1 = clamp(bestV - delta, 0.0, 1.0); let v2 = clamp(bestV + delta, 0.0, 1.0);
        var A1 = bezier(q0[0], q0[1], q0[2], q0[3], v1); var B1 = bezier(q3[0], q3[1], q3[2], q3[3], v1);
        var A2 = bezier(q0[0], q0[1], q0[2], q0[3], v2); var B2 = bezier(q3[0], q3[1], q3[2], q3[3], v2);
        if (xyScale != 1.0) {
            let C1 = (A1 + B1) * 0.5; A1 = C1 + (A1 - C1) * xyScale; B1 = C1 + (B1 - C1) * xyScale;
            let C2 = (A2 + B2) * 0.5; A2 = C2 + (A2 - C2) * xyScale; B2 = C2 + (B2 - C2) * xyScale;
        }
        var w1: f32 = 0.0; var w2: f32 = 0.0;
        let d1 = distToSegment(p.xy, A1, B1, &w1); let d2 = distToSegment(p.xy, A2, B2, &w2);
        if (d1 < d2) { if (d1 < minDist) { minDist = d1; bestV = v1; bestW = w1; } }
        else { if (d2 < minDist) { minDist = d2; bestV = v2; bestW = w2; } }
        delta = delta * 0.5;
    }
    if (minDist > 0.03) { return false; }
    let Zv = bezier1D(zc[0], zc[1], zc[2], zc[3], bestV) * zScale;
    let u = 0.5 + sin(asin(clamp(2.0*bestW - 1.0, -1.0, 1.0)) / 3.0);
    return abs(p.z) < Zv * 3.0 * u * (1.0 - u);
}

fn isInsideSpout(xyz: vec3<f32>, outside: bool) -> bool {
    let b0 = array<vec2<f32>, 4>(vec2<f32>(1.7, 1.275), vec2<f32>(2.6, 1.275), vec2<f32>(2.3, 1.95), vec2<f32>(2.7, 2.25));
    let b3 = array<vec2<f32>, 4>(vec2<f32>(1.7, 0.45), vec2<f32>(3.1, 0.675), vec2<f32>(2.4, 1.875), vec2<f32>(3.3, 2.25));
    let bz = array<f32, 4>(0.66, 0.66, 0.25, 0.25);

    if (!outside) {
        return testHump(xyz, b0, b3, bz, 0.666667, 0.6);
    }

    if (testHump(xyz, b0, b3, bz, 1.0, 1.0)) { return true; }

    let t0 = array<vec2<f32>, 4>(vec2<f32>(2.7, 2.25), vec2<f32>(2.8, 2.325), vec2<f32>(2.9, 2.325), vec2<f32>(2.8, 2.25));
    let t3 = array<vec2<f32>, 4>(vec2<f32>(3.3, 2.25), vec2<f32>(3.525, 2.34375), vec2<f32>(3.45, 2.3625), vec2<f32>(3.2, 2.25));
    let tz = array<f32, 4>(0.25, 0.25, 0.15, 0.15);

    return testHump(xyz, t0, t3, tz, 1.0, 1.0);
}

fn mainModel4(pos: vec3<f32>) -> vec4<f32> {
    let xyz = pos.xzy;
    let spoutSolid = isInsideSpout(xyz, true) && !isInsideSpout(xyz, false);
    let bodySolid = isInsideBody(xyz, true) && !isInsideBody(xyz, false);
    let lidSolid = isInsideLid(xyz, true) && !isInsideLid(xyz, false);
    let handleSolid = isInsideHandle(xyz);
    if (bodySolid || spoutSolid || lidSolid || handleSolid) { return vec4<f32>(1.0, 0.0, 0.0, 0.0); }
    return vec4<f32>(0.0, 0.0, 0.0, 0.0);
}

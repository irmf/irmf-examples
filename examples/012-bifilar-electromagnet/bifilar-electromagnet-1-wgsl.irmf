/*{
  "author": "Glenn M. Lewis",
  "license": "Apache-2.0",
  "date": "2020-02-13",
  "irmf": "1.0",
  "language": "wgsl",
  "materials": ["copper","copper","dielectric"],
  "max": [25,25,71],
  "min": [-25,-25,-63],
  "notes": "The IRMF shader that started it all... the bifilar electromagnet.",
  "options": {
    "resolution": 512,
    "color1": [255,0,0,1],
    "color2": [0,255,0,1],
    "color3": [0,0,255,1]
  },
  "title": "bifilar electromagnet",
  "units": "mm",
  "version": "1.0"
}*/

const M_PI = 3.1415926535897932384626433832795;

fn rotAxis(axis: vec3f, a: f32) -> mat3x3f {
  let s = sin(a);
  let c = cos(a);
  let oc = 1.0 - c;
  let as_ = axis * s;
  let p = mat3x3f(axis.x * axis, axis.y * axis, axis.z * axis);
  let q = mat3x3f(c, as_.z, -as_.y, -as_.z, c, as_.x, as_.y, -as_.x, c);
  return p * oc + q;
}

fn rotZ(angle: f32) -> mat4x4f {
  let m = rotAxis(vec3f(0, 0, 1), angle);
  return mat4x4f(
    vec4f(m[0], 0.0),
    vec4f(m[1], 0.0),
    vec4f(m[2], 0.0),
    vec4f(0.0, 0.0, 0.0, 1.0)
  );
}

fn box_prim(start: vec3f, end: vec3f, size: f32, xyz: vec3f) -> f32 {
  let ll = min(start, end) - vec3f(0.5 * size);
  let ur = max(start, end) + vec3f(0.5 * size);
  if (any(xyz < ll) || any(xyz > ur)) { return 0.0; }
  return 1.0;
}

fn cylinder(radius: f32, height: f32, xyz: vec3f) -> f32 {
  if (xyz.z < 0.0 || xyz.z > height) { return 0.0; }
  let rxy = length(xyz.xy);
  if (rxy > radius) { return 0.0; }
  return 1.0;
}

fn coilSquareFace(radius: f32, size: f32, gap: f32, nTurns: f32, trimEndAngle: f32, xyz: vec3f) -> f32 {
  if (xyz.z < -0.5 * size || xyz.z > nTurns * (size + gap) + 0.5 * size) { return 0.0; }
  let rxy = length(xyz.xy);
  if (rxy < radius - 0.5 * size || rxy > radius + 0.5 * size) { return 0.0; }
  var angle = atan2(xyz.y, xyz.x) / (2.0 * M_PI);
  if (angle < 0.0) { angle += 1.0; }
  let dz = xyz.z - (size + gap) * floor(xyz.z / (size + gap));
  var lastHelixZ = angle * (size + gap);
  var coilNum = 0.0;
  if (lastHelixZ > dz) {
    lastHelixZ -= (size + gap);
    coilNum = -1.0;
  }
  let nextHelixZ = lastHelixZ + (size + gap);
  if (dz > lastHelixZ + 0.5 * size && dz < nextHelixZ - 0.5 * size) { return 0.0; }
  coilNum += floor((xyz.z + (0.5 * size) - lastHelixZ) / (size + gap));
  if (coilNum < 0.0 || coilNum >= nTurns) { return 0.0; }
  return 1.0;
}

fn coilPlusConnectorWires(coilNum: i32, numCoils: i32, inc: f32, innerRadius: f32, connectorRadius: f32, size: f32, gap: f32, nTurns: f32, xyz_in: vec3f) -> f32 {
  let radiusOffset = f32(coilNum - 1);
  let xfm = rotZ(radiusOffset * inc);
  let coilRadius = radiusOffset + innerRadius;
  var trimEndAngle = 2.0 * inc;
  if (coilNum == numCoils) {
    trimEndAngle = 0.5 * inc;
  } else if (coilNum == numCoils - 1) {
    trimEndAngle = 3.0 * inc;
  }
  let xyz = (xfm * vec4f(xyz_in, 1.0)).xyz;
  var coil = coilSquareFace(coilRadius, size, gap, nTurns, trimEndAngle, xyz);
  
  let bz = -(size + gap);
  let tz = nTurns * (size + gap);
  let tzp1 = (nTurns + 1.0) * (size + gap);
  
  coil += box_prim(vec3f(coilRadius, 0.0, 0.0), vec3f(coilRadius, 0.0, bz), size, xyz);
  coil += box_prim(vec3f(coilRadius, 0.0, bz), vec3f(connectorRadius, 0.0, bz), size, xyz);
  coil += box_prim(vec3f(connectorRadius, 0.0, bz), vec3f(connectorRadius, 0.0, tzp1), size, xyz);
  
  let zexit = (nTurns + 10.0) * (size + gap);
  if (coilNum >= 3) {
    let lastCoilRadius = radiusOffset - 2.0 + innerRadius;
    coil += box_prim(vec3f(lastCoilRadius, 0.0, tzp1), vec3f(connectorRadius, 0.0, tzp1), size, xyz);
    coil += box_prim(vec3f(lastCoilRadius, 0.0, tz), vec3f(lastCoilRadius, 0.0, tzp1), size, xyz);
  } else if (coilNum == 2) {
    let endOddRadius = f32(numCoils - 2) + innerRadius;
    coil += box_prim(vec3f(endOddRadius, 0.0, tzp1), vec3f(connectorRadius, 0.0, tzp1), size, xyz);
    coil += box_prim(vec3f(endOddRadius, 0.0, tz), vec3f(endOddRadius, 0.0, tzp1), size, xyz);
  } else if (coilNum == 1) {
    coil += box_prim(vec3f(connectorRadius, 0.0, tz), vec3f(connectorRadius, 0.0, zexit), size, xyz);
  }
  
  if (coilNum == numCoils) {
    let xfm2 = rotZ(0.5 * inc);
    let xyz2 = (xfm2 * vec4f(xyz, 1.0)).xyz;
    coil += box_prim(vec3f(connectorRadius - (size + gap), 0.0, tz), vec3f(connectorRadius - (size + gap), 0.0, zexit), size, xyz2);
  }
  
  return coil;
}

fn bifilarElectromagnet(numPairs: i32, innerRadius: f32, size: f32, gap: f32, numTurns: i32, xyz: vec3f) -> vec3f {
  let nTurns = f32(numTurns);
  let numCoils = 2*numPairs;
  let inc = 2.0 * M_PI / f32(numCoils);
  let connectorRadius = innerRadius + f32(numCoils) * (size + gap);
  
  var metal1 = 0.0;
  var metal2 = 0.0;
  
  for(var i = 1; i <= numCoils; i += 2) {
    metal1 += coilPlusConnectorWires(i, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
    metal2 += coilPlusConnectorWires(i + 1, numCoils, inc, innerRadius, connectorRadius, size, gap, nTurns, xyz);
  }
  metal1 = clamp(metal1, 0.0, 1.0);
  metal2 = clamp(metal2, 0.0, 1.0);
  
  var dielectric = 0.0;
  let dielectricRadius = 2.0 * f32(numPairs) * (size + gap) + innerRadius + gap;
  let dielectricHeight = (nTurns + 4.0) * (size + gap);
  dielectric += cylinder(dielectricRadius, dielectricHeight, xyz + vec3f(0, 0, 2));
  
  let spindleRadius = 2.0 * f32(numPairs + 1) * (size + gap) + innerRadius;
  dielectric += cylinder(spindleRadius, 2.0 * (size + gap), xyz + vec3f(0, 0, 2));
  dielectric += cylinder(spindleRadius, 2.0 * (size + gap), xyz - vec3f(0, 0, dielectricHeight - 4.0));
  dielectric = clamp(dielectric, 0.0, 1.0);
  dielectric -= clamp(metal1 + metal2, 0.0, 1.0);
  
  return vec3f(metal1, metal2, clamp(dielectric, 0.0, 1.0));
}

const innerRadius_val = 3.0;
const wireSize_val = 0.85; // mm
const wireGap_val = 0.15; // mm
const turnsPerCoil_val = 122;
const numCoilPairs_val = 10;

fn mainModel4(xyz_in: vec3f) -> vec4f {
  var xyz = xyz_in;
  let wireSpacing = wireSize_val + wireGap_val;
  xyz.z += f32(turnsPerCoil_val) * wireSpacing / 2.0;
  let res = bifilarElectromagnet(numCoilPairs_val, innerRadius_val, wireSize_val, wireGap_val, turnsPerCoil_val, xyz);
  return vec4f(res, 0.0);
}
